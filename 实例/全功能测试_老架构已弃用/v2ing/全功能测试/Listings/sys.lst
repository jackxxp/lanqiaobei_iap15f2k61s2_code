C51 COMPILER V9.60.7.0   SYS                                                               01/23/2026 22:03:14 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SYS
OBJECT MODULE PLACED IN .\Objects\sys.obj
COMPILER INVOKED BY: C:\Program Files (x86)\keil\C51\BIN\C51.EXE sys.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\sys.lst) TABS(2) OBJECT(.\Objects\sys.obj)

line level    source

   1          //sys.c
   2          #include "sys.h"
   3          
   4          
   5          static uint16 app_tick = 0;
   6          
   7          // 新增：一次性标志位（由中断置1，由用户函数读取后清0）
   8          static bit flag_100ms = 0;
   9          static bit flag_1s = 0;
  10          
  11          void sys_init()
  12          {
  13   1        gpio_init();
  14   1        
  15   1        
  16   1        decoder_init();
  17   1        y5driver_init();
  18   1        
  19   1        led_init();
  20   1        seg_init();
  21   1        
  22   1        sys_timer_init();
  23   1      
  24   1      }
  25          
  26          void gpio_init()
  27          {
  28   1        P0M0 = 0x00;
  29   1        P0M1 = 0x00;
  30   1        P1M0 = 0x00;
  31   1        P1M1 = 0x00;
  32   1        P2M0 = 0x00;
  33   1        P2M1 = 0x00;
  34   1        P3M0 = 0x00;
  35   1        P3M1 = 0x00;
  36   1        P4M0 = 0x00;
  37   1        P4M1 = 0x00;
  38   1        P5M0 = 0x00;
  39   1        P5M1 = 0x00;
  40   1        P6M0 = 0x00;
  41   1        P6M1 = 0x00;
  42   1        P7M0 = 0x00;
  43   1        P7M1 = 0x00;
  44   1      }
  45          
  46          void sys_timer_init()
  47          {
  48   1        AUXR &= 0xBF; // 定时器时钟12T模式
  49   1        TMOD &= 0x0F; // 设置定时器模式
  50   1        TL1 = 0x18;   // 设置定时初始值
  51   1        TH1 = 0xFC;   // 设置定时初始值
  52   1        TF1 = 0;      // 清除TF1标志
  53   1        TR1 = 1;      // 定时器1开始计时
  54   1        ET1 = 1;      // 使能定时器1中断
C51 COMPILER V9.60.7.0   SYS                                                               01/23/2026 22:03:14 PAGE 2   

  55   1        
  56   1        EA = 1;
  57   1      }
  58          
  59          void sys_sleep_1s()//12mhz
  60          {
  61   1        unsigned char data i, j, k;
  62   1      
  63   1        _nop_();
  64   1        _nop_();
  65   1        i = 46;
  66   1        j = 153;
  67   1        k = 245;
  68   1        do
  69   1        {
  70   2          do
  71   2          {
  72   3            while (--k);
  73   3          } while (--j);
  74   2        } while (--i);
  75   1      }
  76          
  77          void sys_sleep_100ms()//12mhz
  78          {
  79   1        unsigned char data i, j, k;
  80   1      
  81   1        _nop_();
  82   1        _nop_();
  83   1        i = 5;
  84   1        j = 144;
  85   1        k = 71;
  86   1        do
  87   1        {
  88   2          do
  89   2          {
  90   3            while (--k);
  91   3          } while (--j);
  92   2        } while (--i);
  93   1      }
  94          
  95          //void sys_sleep_1ms()//12mhz
  96          //{
  97          //  unsigned char data i, j;
  98          
  99          //  i = 12;
 100          //  j = 169;
 101          //  do
 102          //  {
 103          //    while (--j);
 104          //  } while (--i);
 105          //}
 106          
 107          // 定时器中断中更新 tick 和标志
 108          void app_tick_run()
 109          {
 110   1          static uint8 cnt_100ms = 0;
 111   1          static uint8 cnt_1s = 0;
 112   1          app_tick++;
 113   1          if (app_tick >= 60000) app_tick = 0;
 114   1      
 115   1          // 每 10 次 tick（即 10ms？）→ 但你想 100ms，所以应为 100
 116   1          // 注意：你的 app_tick 是每 1ms 增1 吗？
C51 COMPILER V9.60.7.0   SYS                                                               01/23/2026 22:03:14 PAGE 3   

 117   1          // 从 TL1=0x18, TH1=0xFC 推算：定时约 1ms，所以：
 118   1          
 119   1      
 120   1      
 121   1          if (++cnt_100ms >= 10) {   // 100 * 1ms = 100ms
 122   2              cnt_100ms = 0;
 123   2              flag_100ms = 1;         // 置位一次
 124   2          }
 125   1      
 126   1          if (++cnt_1s >= 100) {     // 1000 * 1ms = 1s
 127   2              cnt_1s = 0;
 128   2              flag_1s = 1;            // 置位一次
 129   2          }
 130   1      }
 131          
 132          // ✅ 提供“用完即清”的接口函数
 133          bit get_100ms_flag(void)
 134          {
 135   1          if (flag_100ms) {
 136   2              flag_100ms = 0; // 读取后立即清除
 137   2              return 1;
 138   2          }
 139   1          return 0;
 140   1      }
 141          
 142          bit get_1s_flag(void)
 143          {
 144   1          if (flag_1s) {
 145   2              flag_1s = 0;
 146   2              return 1;
 147   2          }
 148   1          return 0;
 149   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    181    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
