C51 COMPILER V9.60.7.0   SYS                                                               01/21/2026 17:11:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SYS
OBJECT MODULE PLACED IN .\Objects\sys.obj
COMPILER INVOKED BY: C:\Program Files (x86)\keil\C51\BIN\C51.EXE sys.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\sys.lst) TABS(2) OBJECT(.\Objects\sys.obj)

line level    source

   1          //sys.c
   2          #include "sys.h"
   3          
   4          
   5          static uint16 app_tick = 0;
   6          
   7          // 新增：一次性标志位（由中断置1，由用户函数读取后清0）
   8          static bit flag_100ms = 0;
   9          static bit flag_1s = 0;
  10          
  11          void sys_init()
  12          {
  13   1        gpio_init();
  14   1        
  15   1        decoder_init();
  16   1        led_init();
  17   1        seg_init();
  18   1        
  19   1        sys_timer_init();
  20   1      
  21   1      }
  22          
  23          void gpio_init()
  24          {
  25   1        P0M0 = 0x00;
  26   1        P0M1 = 0x00;
  27   1        P1M0 = 0x00;
  28   1        P1M1 = 0x00;
  29   1        P2M0 = 0x00;
  30   1        P2M1 = 0x00;
  31   1        P3M0 = 0x00;
  32   1        P3M1 = 0x00;
  33   1        P4M0 = 0x00;
  34   1        P4M1 = 0x00;
  35   1        P5M0 = 0x00;
  36   1        P5M1 = 0x00;
  37   1        P6M0 = 0x00;
  38   1        P6M1 = 0x00;
  39   1        P7M0 = 0x00;
  40   1        P7M1 = 0x00;
  41   1      }
  42          
  43          void sys_timer_init()
  44          {
  45   1        AUXR &= 0xBF; // 定时器时钟12T模式
  46   1        TMOD &= 0x0F; // 设置定时器模式
  47   1        TL1 = 0x18;   // 设置定时初始值
  48   1        TH1 = 0xFC;   // 设置定时初始值
  49   1        TF1 = 0;      // 清除TF1标志
  50   1        TR1 = 1;      // 定时器1开始计时
  51   1        ET1 = 1;      // 使能定时器1中断
  52   1        
  53   1        EA = 1;
  54   1      }
C51 COMPILER V9.60.7.0   SYS                                                               01/21/2026 17:11:19 PAGE 2   

  55          
  56          void sys_sleep_1s()//12mhz
  57          {
  58   1        unsigned char data i, j, k;
  59   1      
  60   1        _nop_();
  61   1        _nop_();
  62   1        i = 46;
  63   1        j = 153;
  64   1        k = 245;
  65   1        do
  66   1        {
  67   2          do
  68   2          {
  69   3            while (--k);
  70   3          } while (--j);
  71   2        } while (--i);
  72   1      }
  73          
  74          void sys_sleep_100ms()//12mhz
  75          {
  76   1        unsigned char data i, j, k;
  77   1      
  78   1        _nop_();
  79   1        _nop_();
  80   1        i = 5;
  81   1        j = 144;
  82   1        k = 71;
  83   1        do
  84   1        {
  85   2          do
  86   2          {
  87   3            while (--k);
  88   3          } while (--j);
  89   2        } while (--i);
  90   1      }
  91          
  92          //void sys_sleep_1ms()//12mhz
  93          //{
  94          //  unsigned char data i, j;
  95          
  96          //  i = 12;
  97          //  j = 169;
  98          //  do
  99          //  {
 100          //    while (--j);
 101          //  } while (--i);
 102          //}
 103          
 104          // 定时器中断中更新 tick 和标志
 105          void app_tick_run()
 106          {
 107   1          static uint8 cnt_100ms = 0;
 108   1          static uint8 cnt_1s = 0;
 109   1          app_tick++;
 110   1          if (app_tick >= 60000) app_tick = 0;
 111   1      
 112   1          // 每 10 次 tick（即 10ms？）→ 但你想 100ms，所以应为 100
 113   1          // 注意：你的 app_tick 是每 1ms 增1 吗？
 114   1          // 从 TL1=0x18, TH1=0xFC 推算：定时约 1ms，所以：
 115   1          
 116   1      
C51 COMPILER V9.60.7.0   SYS                                                               01/21/2026 17:11:19 PAGE 3   

 117   1      
 118   1          if (++cnt_100ms >= 10) {   // 100 * 1ms = 100ms
 119   2              cnt_100ms = 0;
 120   2              flag_100ms = 1;         // 置位一次
 121   2          }
 122   1      
 123   1          if (++cnt_1s >= 100) {     // 1000 * 1ms = 1s
 124   2              cnt_1s = 0;
 125   2              flag_1s = 1;            // 置位一次
 126   2          }
 127   1      }
 128          
 129          // ✅ 提供“用完即清”的接口函数
 130          bit get_100ms_flag(void)
 131          {
 132   1          if (flag_100ms) {
 133   2              flag_100ms = 0; // 读取后立即清除
 134   2              return 1;
 135   2          }
 136   1          return 0;
 137   1      }
 138          
 139          bit get_1s_flag(void)
 140          {
 141   1          if (flag_1s) {
 142   2              flag_1s = 0;
 143   2              return 1;
 144   2          }
 145   1          return 0;
 146   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    178    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
